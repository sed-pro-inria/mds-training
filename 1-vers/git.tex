
% Default to the notebook output style

    


% Inherit from the specified cell style.




    
\documentclass{article}

    
    
    \usepackage{graphicx} % Used to insert images
    \usepackage{adjustbox} % Used to constrain images to a maximum size 
    \usepackage{color} % Allow colors to be defined
    \usepackage{enumerate} % Needed for markdown enumerations to work
    \usepackage{geometry} % Used to adjust the document margins
    \usepackage{amsmath} % Equations
    \usepackage{amssymb} % Equations
    \usepackage[mathletters]{ucs} % Extended unicode (utf-8) support
    \usepackage[utf8x]{inputenc} % Allow utf-8 characters in the tex document
    \usepackage{fancyvrb} % verbatim replacement that allows latex
    \usepackage{grffile} % extends the file name processing of package graphics 
                         % to support a larger range 
    % The hyperref package gives us a pdf with properly built
    % internal navigation ('pdf bookmarks' for the table of contents,
    % internal cross-reference links, web links for URLs, etc.)
    \usepackage{hyperref}
    \usepackage{longtable} % longtable support required by pandoc >1.10
    \usepackage{booktabs}  % table support for pandoc > 1.12.2
    

    
    
    \definecolor{orange}{cmyk}{0,0.4,0.8,0.2}
    \definecolor{darkorange}{rgb}{.71,0.21,0.01}
    \definecolor{darkgreen}{rgb}{.12,.54,.11}
    \definecolor{myteal}{rgb}{.26, .44, .56}
    \definecolor{gray}{gray}{0.45}
    \definecolor{lightgray}{gray}{.95}
    \definecolor{mediumgray}{gray}{.8}
    \definecolor{inputbackground}{rgb}{.95, .95, .85}
    \definecolor{outputbackground}{rgb}{.95, .95, .95}
    \definecolor{traceback}{rgb}{1, .95, .95}
    % ansi colors
    \definecolor{red}{rgb}{.6,0,0}
    \definecolor{green}{rgb}{0,.65,0}
    \definecolor{brown}{rgb}{0.6,0.6,0}
    \definecolor{blue}{rgb}{0,.145,.698}
    \definecolor{purple}{rgb}{.698,.145,.698}
    \definecolor{cyan}{rgb}{0,.698,.698}
    \definecolor{lightgray}{gray}{0.5}
    
    % bright ansi colors
    \definecolor{darkgray}{gray}{0.25}
    \definecolor{lightred}{rgb}{1.0,0.39,0.28}
    \definecolor{lightgreen}{rgb}{0.48,0.99,0.0}
    \definecolor{lightblue}{rgb}{0.53,0.81,0.92}
    \definecolor{lightpurple}{rgb}{0.87,0.63,0.87}
    \definecolor{lightcyan}{rgb}{0.5,1.0,0.83}
    
    % commands and environments needed by pandoc snippets
    % extracted from the output of `pandoc -s`
    \DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
    % Add ',fontsize=\small' for more characters per line
    \newenvironment{Shaded}{}{}
    \newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{{#1}}}}
    \newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.56,0.13,0.00}{{#1}}}
    \newcommand{\DecValTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
    \newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
    \newcommand{\FloatTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
    \newcommand{\CharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
    \newcommand{\StringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
    \newcommand{\CommentTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textit{{#1}}}}
    \newcommand{\OtherTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{{#1}}}
    \newcommand{\AlertTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{{#1}}}}
    \newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.02,0.16,0.49}{{#1}}}
    \newcommand{\RegionMarkerTok}[1]{{#1}}
    \newcommand{\ErrorTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{{#1}}}}
    \newcommand{\NormalTok}[1]{{#1}}
    
    % Define a nice break command that doesn't care if a line doesn't already
    % exist.
    \def\br{\hspace*{\fill} \\* }
    % Math Jax compatability definitions
    \def\gt{>}
    \def\lt{<}
    % Document parameters
    \title{git}
    
    
    

    % Pygments definitions
    
\makeatletter
\def\PY@reset{\let\PY@it=\relax \let\PY@bf=\relax%
    \let\PY@ul=\relax \let\PY@tc=\relax%
    \let\PY@bc=\relax \let\PY@ff=\relax}
\def\PY@tok#1{\csname PY@tok@#1\endcsname}
\def\PY@toks#1+{\ifx\relax#1\empty\else%
    \PY@tok{#1}\expandafter\PY@toks\fi}
\def\PY@do#1{\PY@bc{\PY@tc{\PY@ul{%
    \PY@it{\PY@bf{\PY@ff{#1}}}}}}}
\def\PY#1#2{\PY@reset\PY@toks#1+\relax+\PY@do{#2}}

\expandafter\def\csname PY@tok@il\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@mb\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@mi\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@k\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@ss\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\expandafter\def\csname PY@tok@kd\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@nt\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@sb\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@c\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\expandafter\def\csname PY@tok@w\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\expandafter\def\csname PY@tok@ge\endcsname{\let\PY@it=\textit}
\expandafter\def\csname PY@tok@nv\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\expandafter\def\csname PY@tok@ne\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.82,0.25,0.23}{##1}}}
\expandafter\def\csname PY@tok@kn\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@kr\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@kt\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.69,0.00,0.25}{##1}}}
\expandafter\def\csname PY@tok@sx\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@sr\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.40,0.53}{##1}}}
\expandafter\def\csname PY@tok@s2\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@vi\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\expandafter\def\csname PY@tok@gi\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\expandafter\def\csname PY@tok@gp\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PY@tok@go\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.53,0.53,0.53}{##1}}}
\expandafter\def\csname PY@tok@nf\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
\expandafter\def\csname PY@tok@nc\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
\expandafter\def\csname PY@tok@s\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@gt\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.27,0.87}{##1}}}
\expandafter\def\csname PY@tok@sc\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@sd\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@ow\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.67,0.13,1.00}{##1}}}
\expandafter\def\csname PY@tok@m\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@gr\endcsname{\def\PY@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\expandafter\def\csname PY@tok@kp\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@c1\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\expandafter\def\csname PY@tok@sh\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@bp\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@si\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.73,0.40,0.53}{##1}}}
\expandafter\def\csname PY@tok@gd\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\expandafter\def\csname PY@tok@cm\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\expandafter\def\csname PY@tok@o\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@vg\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\expandafter\def\csname PY@tok@se\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.73,0.40,0.13}{##1}}}
\expandafter\def\csname PY@tok@mo\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@s1\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@gh\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PY@tok@kc\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@mh\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@mf\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@gs\endcsname{\let\PY@bf=\textbf}
\expandafter\def\csname PY@tok@nb\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@nl\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.63,0.63,0.00}{##1}}}
\expandafter\def\csname PY@tok@cp\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.74,0.48,0.00}{##1}}}
\expandafter\def\csname PY@tok@nd\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.67,0.13,1.00}{##1}}}
\expandafter\def\csname PY@tok@nn\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
\expandafter\def\csname PY@tok@cs\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\expandafter\def\csname PY@tok@vc\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\expandafter\def\csname PY@tok@gu\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\expandafter\def\csname PY@tok@no\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.53,0.00,0.00}{##1}}}
\expandafter\def\csname PY@tok@err\endcsname{\def\PY@bc##1{\setlength{\fboxsep}{0pt}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}
\expandafter\def\csname PY@tok@na\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.49,0.56,0.16}{##1}}}
\expandafter\def\csname PY@tok@ni\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.60,0.60,0.60}{##1}}}

\def\PYZbs{\char`\\}
\def\PYZus{\char`\_}
\def\PYZob{\char`\{}
\def\PYZcb{\char`\}}
\def\PYZca{\char`\^}
\def\PYZam{\char`\&}
\def\PYZlt{\char`\<}
\def\PYZgt{\char`\>}
\def\PYZsh{\char`\#}
\def\PYZpc{\char`\%}
\def\PYZdl{\char`\$}
\def\PYZhy{\char`\-}
\def\PYZsq{\char`\'}
\def\PYZdq{\char`\"}
\def\PYZti{\char`\~}
% for compatibility with earlier versions
\def\PYZat{@}
\def\PYZlb{[}
\def\PYZrb{]}
\makeatother


    % Exact colors from NB
    \definecolor{incolor}{rgb}{0.0, 0.0, 0.5}
    \definecolor{outcolor}{rgb}{0.545, 0.0, 0.0}



    
    % Prevent overflowing lines due to hard-to-break entities
    \sloppy 
    % Setup hyperref package
    \hypersetup{
      breaklinks=true,  % so long urls are correctly broken across lines
      colorlinks=true,
      urlcolor=blue,
      linkcolor=darkorange,
      citecolor=darkgreen,
      }
    % Slightly bigger margins than the latex defaults
    
    \geometry{verbose,tmargin=1in,bmargin=1in,lmargin=1in,rmargin=1in}
    
    

    \begin{document}
    
    
    \maketitle
    
    

    

    \section{Version control with Git}


    

    \textbf{Part 1: Local version control (only one Git repository)}

\begin{itemize}
\item
  The init command
\item
  The add, commit and log commands
\item
  How it works: working copy, staging area (index) and database.
\item
  The diff and status commands
\item
  The log command
\item
  The checkout command
\item
  More on commits
\item
  The SHA-1
\item
  Git branches
\item
  The merge command
\item
  What Git branches are
\end{itemize}
\textbf{Part 2: Centralized (à la cvs/svn) version control}

\begin{itemize}
\item
  The --bare option of the init command
\item
  The remote command
\item
  The push command
\item
  The fetch command
\item
  Remote branches
\item
  Pushing a (feature) branch
\item
  Tracking branch
\item
  Visualizing branches
\end{itemize}
\textbf{Part 3: Distributed workflow}


    \subsection{Git, a distributed Version Control System}


    Version control means keeping track of code evlolution by recording the
code's state after each meaningful change. This is useful: - To cancel a
non-working modification - To perform regression tests / continuous
integration

The database where the different states of the code are recorded can be:
- Local: the project has only one developer - Centralised: it is
available on a server but developers do not receive it when they get the
project's sources (cvs, svn). - Distributed: every developer that has
the sources also has the full code history (git, mercurial, darcs).

Version Control Manager: - Source code is frequently \textbf{committed}
into Git database, and each \textbf{commit} can be retrieved, shared
with team. - Keep, search your code history. - Develop software in team
efficiently.

Distributed: - Unlike \textbf{SVN} which is \textbf{centralized},
\textbf{Git} is \textbf{distributed}. It means that Git does not require
to use one central repository, but multiple ones may be used. - When one
downloads source code from a Git repository, it creates a new Git
repository, with the full database. There is no conceptual difference
between the two repositories. - Offline work possibility - Multiple
possible workflows to collaborate with other developers.

Some terminology: - Repository: the vesion-controlled project and
optionally the database containing the project's history. - Commit: one
record of the code's state in the project's history. - Branch: maintain
several versions of the project in parallel

\textbf{Git} makes it easy to work with \textbf{branches}. - Branches
are easy to create, merge and destroy. - Creating temporary branches to
develop a feature is encouraged.

\textbf{Git} has a few core concepts that must be understood. - Without
knowing these core concepts, using Git is frustrating and painful. -
Knowing them, using Git is powerful and easy.

Thanks to Git's simplicity for creating new repositories and managing
branches, a workflow adapted to your team may be chosen. For example: -
working with a central repository and contributing into branches (small
private teams); - working with forks and contributing with pull requests
(large teams with external contributors).

This presentation deals with the core concepts of Git, so as to make its
adoption easier.


    \subsection{Local version control (only one Git repository)}


    We start working on a single repository.

In this section, we will learn the core concepts of Git: - commits, -
staging area (index), - branches.

Start by creating a new empty directory to experiment with Git:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}1}]:} \PY{k+kn}{from} \PY{n+nn}{os} \PY{k+kn}{import} \PY{n}{makedirs}\PY{p}{,} \PY{n}{chdir}\PY{p}{,} \PY{n}{curdir}\PY{p}{,} \PY{n}{walk}\PY{p}{,} \PY{n}{sep}
        \PY{k+kn}{from} \PY{n+nn}{os.path} \PY{k+kn}{import} \PY{n}{expanduser}\PY{p}{,} \PY{n}{isdir}\PY{p}{,} \PY{n}{abspath}\PY{p}{,} \PY{n}{join}\PY{p}{,} \PY{n}{relpath}\PY{p}{,} \PY{n}{basename}
        \PY{k+kn}{from} \PY{n+nn}{shutil} \PY{k+kn}{import} \PY{n}{rmtree}
        
        \PY{n}{workdir} \PY{o}{=} \PY{n}{expanduser}\PY{p}{(}\PY{l+s}{\PYZsq{}}\PY{l+s}{\PYZti{}/git\PYZhy{}training}\PY{l+s}{\PYZsq{}}\PY{p}{)}
        
        \PY{c}{\PYZsh{} Remove possible existing working, and starts with a fresh one.}
        \PY{k}{if} \PY{n}{isdir}\PY{p}{(}\PY{n}{workdir}\PY{p}{)}\PY{p}{:}
            \PY{n}{rmtree}\PY{p}{(}\PY{n}{workdir}\PY{p}{)}
        \PY{n}{makedirs}\PY{p}{(}\PY{n}{workdir}\PY{p}{)}
        
        \PY{k}{def} \PY{n+nf}{changedir}\PY{p}{(}\PY{n}{directory}\PY{p}{)}\PY{p}{:}
            \PY{l+s+sd}{\PYZdq{}\PYZdq{}\PYZdq{}Set up a directory relative to workdir\PYZdq{}\PYZdq{}\PYZdq{}}
            \PY{n}{directory} \PY{o}{=} \PY{n}{abspath}\PY{p}{(}\PY{n}{join}\PY{p}{(}\PY{n}{workdir}\PY{p}{,}\PY{n}{directory}\PY{p}{)}\PY{p}{)}
            \PY{k}{if} \PY{o+ow}{not} \PY{n}{isdir}\PY{p}{(}\PY{n}{directory}\PY{p}{)}\PY{p}{:}
                \PY{n}{makedirs}\PY{p}{(}\PY{n}{directory}\PY{p}{)}
            \PY{n}{chdir}\PY{p}{(}\PY{n}{directory}\PY{p}{)}
            \PY{k}{print}\PY{p}{(}\PY{l+s}{\PYZdq{}}\PY{l+s}{We are in directory }\PY{l+s}{\PYZdq{}} \PY{o}{+} \PY{n}{directory}\PY{p}{)}
            
        \PY{c}{\PYZsh{} The directory that will contain the Git repository}
        \PY{n}{changedir}\PY{p}{(}\PY{l+s}{\PYZsq{}}\PY{l+s}{repo}\PY{l+s}{\PYZsq{}}\PY{p}{)}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
We are in directory /home/ROCQ/sedrocq/froger/git-training/repo
    \end{Verbatim}


    \subsubsection{The init command}


    A Git \textbf{repository} is created in the current directory using the
\textbf{init} command.

This will create a \texttt{.git} hidden directory, where Git stores its
database.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}2}]:} \PY{o}{\PYZpc{}\PYZpc{}}\PY{k}{bash}
        \PY{n}{git} \PY{n}{init}
        \PY{n}{ls} \PY{o}{\PYZhy{}}\PY{n}{la}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
Initialized empty Git repository in /nas/home3/f/froger/git-training/repo/.git/
total 12
drwxr-xr-x 3 froger sed 4096 Jun  4 10:18 .
drwxr-xr-x 3 froger sed 4096 Jun  4 10:18 ..
drwxr-xr-x 7 froger sed 4096 Jun  4 10:18 .git
    \end{Verbatim}

    You can now start developing. For example, we may write ``First Line''
in a file called \texttt{foo.txt}. But in practice, we would probably
want to write some real source code.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}3}]:} \PY{o}{\PYZpc{}\PYZpc{}}\PY{k}{bash}
        \PY{n}{echo} \PY{l+s}{\PYZdq{}}\PY{l+s}{First line}\PY{l+s}{\PYZdq{}} \PY{o}{\PYZgt{}} \PY{n}{foo}\PY{o}{.}\PY{n}{txt}
\end{Verbatim}


    \subsubsection{The add, commit and log commands}


    To record (commit) the previous changes to Git's database, do as
follows:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}4}]:} \PY{o}{\PYZpc{}\PYZpc{}}\PY{k}{bash}
        \PY{n}{git} \PY{n}{add} \PY{n}{foo}\PY{o}{.}\PY{n}{txt}
        \PY{n}{git} \PY{n}{commit} \PY{o}{\PYZhy{}}\PY{n}{m} \PY{l+s}{\PYZdq{}}\PY{l+s}{Initial commit.}\PY{l+s}{\PYZdq{}}  
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
[master (root-commit) 03ae0f2] Initial commit.
 1 file changed, 1 insertion(+)
 create mode 100644 foo.txt
    \end{Verbatim}

    The \textbf{add} command tells Git to track changes in the file
\texttt{foo.txt} and says that the current content of this file should
be commited by the next \textbf{commit} command.

The \textbf{commit} command itself then records (commits) all the added
changes to git's database and associates a few metadata to this set of
changes.

The argument of -m is a commit message, that is, a description of the
commited change. The commit message is mandatory. If -m is not given,
the \textbf{commit} command will open an editor where the commit message
should be typed.

To make sure things have been properly commited, one may use the
\textbf{log} command:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}5}]:} \PY{o}{\PYZpc{}\PYZpc{}}\PY{k}{bash}
        \PY{n}{git} \PY{n}{log}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
commit 03ae0f2377799f15cc1988d24fe9f777e37b07f2
Author: David Froger <david.froger@inria.fr>
Date:   Thu Jun 4 10:18:25 2015 +0200

    Initial commit.
    \end{Verbatim}

    As can be seen, the metadata associated with the commit includes its
author. However, the name or e-mail address printed at the moment may
not look so pretty. Here is how to improve this for future commits:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}6}]:} \PY{o}{\PYZpc{}\PYZpc{}}\PY{k}{bash}
        \PY{c}{\PYZsh{} git config \PYZhy{}\PYZhy{}global user.name \PYZdq{}Prénom Nom\PYZdq{}}
        \PY{c}{\PYZsh{} git config \PYZhy{}\PYZhy{}global user.email prenom.nom@inria.fr}
\end{Verbatim}

    It is even possible to fix the authorship of our previous commit:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}7}]:} \PY{o}{\PYZpc{}\PYZpc{}}\PY{k}{bash}
        \PY{c}{\PYZsh{}git commit \PYZhy{}\PYZhy{}amend \PYZhy{}\PYZhy{}reset\PYZhy{}author }
\end{Verbatim}

    And let's make sure this actually worked:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}8}]:} \PY{o}{\PYZpc{}\PYZpc{}}\PY{k}{bash}
        \PY{n}{git} \PY{n}{log}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
commit 03ae0f2377799f15cc1988d24fe9f777e37b07f2
Author: David Froger <david.froger@inria.fr>
Date:   Thu Jun 4 10:18:25 2015 +0200

    Initial commit.
    \end{Verbatim}

    Note: we used the \textbf{--local} flag here so that the configuration
applies only to the current repository, but one can also use the
\textbf{--global} flag to make the coniguration the default for all
repositories, given that it can then be overloaded in each repository.


    \subsubsection{How it works: working copy, staging area (index) and database.}


    Woking copy and database are conceps which are well known in other
revision control systems. To these, Git adds a third zone, the staging
area. It is an intermediary place where changes go before being commited
to Git's database.

Having this third area may seem odd at first, but it turns out to be
useful e.g.~to seperate commits, as we will see.

Suppose we add two lines to foo.txt:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}9}]:} \PY{o}{\PYZpc{}\PYZpc{}}\PY{k}{bash}
        \PY{n}{echo} \PY{l+s}{\PYZdq{}}\PY{l+s}{Second line}\PY{l+s}{\PYZdq{}} \PY{o}{\PYZgt{}\PYZgt{}} \PY{n}{foo}\PY{o}{.}\PY{n}{txt}
        \PY{n}{echo} \PY{l+s}{\PYZdq{}}\PY{l+s}{Third line}\PY{l+s}{\PYZdq{}} \PY{o}{\PYZgt{}\PYZgt{}} \PY{n}{foo}\PY{o}{.}\PY{n}{txt}
\end{Verbatim}

    But then we realise that these two lines really represent two distinct
changes and should thus be commited separately.

Git makes it possible to achieve this thanks to its index or staging
area, like this:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}10}]:} \PY{o}{\PYZpc{}\PYZpc{}}\PY{k}{bash}
         \PY{c}{\PYZsh{}git add \PYZhy{}p foo.txt}
\end{Verbatim}

    And choose `e' to edit the hunk, then remove the line

+Third line

so that the only line starting wih a + symbol ``Second line''.

To make sure only the second line has been added to the index and will
thus be commited, use the \textbf{diff} command as follows:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}11}]:} \PY{o}{\PYZpc{}\PYZpc{}}\PY{k}{bash}
         \PY{n}{git} \PY{n}{diff} \PY{o}{\PYZhy{}}\PY{o}{\PYZhy{}}\PY{n}{cached}
\end{Verbatim}

    Before continuing, notice how we now have three different versions of
foo.txt:

\begin{itemize}
\item
  One in the working copy (3 lines)
\item
  One in the index (2 lines)
\item
  One in the database (1 line)
\end{itemize}
Let's commit what has been staged:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}12}]:} \PY{o}{\PYZpc{}\PYZpc{}}\PY{k}{bash}
         \PY{n}{git} \PY{n}{commit} \PY{o}{\PYZhy{}}\PY{n}{m} \PY{l+s}{\PYZdq{}}\PY{l+s}{Second commit}\PY{l+s}{\PYZdq{}} 
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
\# On branch master
\# Changes not staged for commit:
\#   (use "git add <file>\ldots" to update what will be committed)
\#   (use "git checkout -- <file>\ldots" to discard changes in working directory)
\#
\#	modified:   foo.txt
\#
no changes added to commit (use "git add" and/or "git commit -a")
    \end{Verbatim}

    Let's make sure the commit has worked:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}13}]:} \PY{o}{\PYZpc{}\PYZpc{}}\PY{k}{bash}
         \PY{n}{git} \PY{n}{log}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
commit 03ae0f2377799f15cc1988d24fe9f777e37b07f2
Author: David Froger <david.froger@inria.fr>
Date:   Thu Jun 4 10:18:25 2015 +0200

    Initial commit.
    \end{Verbatim}

    And note that the staging area is now empty:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}14}]:} \PY{o}{\PYZpc{}\PYZpc{}}\PY{k}{bash}
         \PY{n}{git} \PY{n}{diff} \PY{o}{\PYZhy{}}\PY{o}{\PYZhy{}}\PY{n}{cached}
\end{Verbatim}

    We can now commit our second change to foo.txt:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}15}]:} \PY{o}{\PYZpc{}\PYZpc{}}\PY{k}{bash}
         \PY{n}{git} \PY{n}{add} \PY{n}{foo}\PY{o}{.}\PY{n}{txt}
         \PY{n}{git} \PY{n}{commit} \PY{o}{\PYZhy{}}\PY{n}{m} \PY{l+s}{\PYZdq{}}\PY{l+s}{Third commit}\PY{l+s}{\PYZdq{}}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
[master 2e8215d] Third commit
 1 file changed, 2 insertions(+)
    \end{Verbatim}

    Two remarks are due here:

\begin{enumerate}[1.]
\item
  The example we have jsut seen to understand why the staging area is
  useful is quite artificial. It is however rather imortant, because the
  situation it describes can happen quite a lot in practice. For
  instance, suppose that while adding a feature to a program one
  discovers typos in the existing code. The new feature and the typo
  fixups could for sure be commited together, but doing two distinct
  commits is considered better practice because it gives a cleaner
  history (In particular, should the feature be removed later, that
  could be achieved without loosing the typo fixups.)
\end{enumerate}
In such a situation, the -p flag to the add command turns out to be
especially useful. Moreover, since the changes happen most of the time
in different hunks (regions), it will be easier to use the interactive
\textbf{add} in such situations than in the one above, since it will not
require any manual hunk edition as before.

\begin{enumerate}[1.]
\setcounter{enumi}{1}
\item
  The three areas that have just been introduced (working copy, staging
  area and commit database) are of crucial importance. Indeed, almost
  all git commands either manipulate one of these areas or transfer
  content between two of them and understanding Git in terms of how the
  commands work on areas turns out to be especially helpful (if not
  fundamental) in practice.
\end{enumerate}
Moreover, for one specific command, its arguments may change the areas
it affects. As an example, git commit transfers content from the staging
area to the database, but with the -a argument, the same command will
transfer all the uncommited (and unstaged) changes directly from the
working copy to the database and leave the staging area unmodified.

Exercise: can you explain what \textbf{log} and \textbf{add} do in terms
of the three areas?


    \subsubsection{The diff and status commands}


    Modify the \texttt{foo.txt} file, and observe the outputs of the
\textbf{diff} and \textbf{status} commands

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}16}]:} \PY{o}{\PYZpc{}\PYZpc{}}\PY{k}{bash}
         \PY{n}{echo} \PY{l+s}{\PYZsq{}}\PY{l+s}{Fourth line}\PY{l+s}{\PYZsq{}} \PY{o}{\PYZgt{}\PYZgt{}} \PY{n}{foo}\PY{o}{.}\PY{n}{txt}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}17}]:} \PY{o}{\PYZpc{}\PYZpc{}}\PY{k}{bash}
         \PY{n}{git} \PY{n}{diff}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
diff --git a/foo.txt b/foo.txt
index 6da4d3e..5028ae5 100644
--- a/foo.txt
+++ b/foo.txt
@@ -1,3 +1,4 @@
 First line
 Second line
 Third line
+Fourth line
    \end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}18}]:} \PY{o}{\PYZpc{}\PYZpc{}}\PY{k}{bash}
         \PY{n}{git} \PY{n}{status}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
\# On branch master
\# Changes not staged for commit:
\#   (use "git add <file>\ldots" to update what will be committed)
\#   (use "git checkout -- <file>\ldots" to discard changes in working directory)
\#
\#	modified:   foo.txt
\#
no changes added to commit (use "git add" and/or "git commit -a")
    \end{Verbatim}

    Stage the file, and observe the new outputs of the \textbf{diff} and
\textbf{status} commands

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}19}]:} \PY{o}{\PYZpc{}\PYZpc{}}\PY{k}{bash}
         \PY{n}{git} \PY{n}{add} \PY{n}{foo}\PY{o}{.}\PY{n}{txt}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}20}]:} \PY{o}{\PYZpc{}\PYZpc{}}\PY{k}{bash}
         \PY{n}{git} \PY{n}{diff}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}21}]:} \PY{o}{\PYZpc{}\PYZpc{}}\PY{k}{bash}
         \PY{n}{git} \PY{n}{diff} \PY{o}{\PYZhy{}}\PY{o}{\PYZhy{}}\PY{n}{cached}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
diff --git a/foo.txt b/foo.txt
index 6da4d3e..5028ae5 100644
--- a/foo.txt
+++ b/foo.txt
@@ -1,3 +1,4 @@
 First line
 Second line
 Third line
+Fourth line
    \end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}22}]:} \PY{o}{\PYZpc{}\PYZpc{}}\PY{k}{bash}
         \PY{n}{git} \PY{n}{status}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
\# On branch master
\# Changes to be committed:
\#   (use "git reset HEAD <file>\ldots" to unstage)
\#
\#	modified:   foo.txt
\#
    \end{Verbatim}

    Commit the file.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}23}]:} \PY{o}{\PYZpc{}\PYZpc{}}\PY{k}{bash}
         \PY{n}{git} \PY{n}{commit} \PY{o}{\PYZhy{}}\PY{n}{m} \PY{l+s}{\PYZsq{}}\PY{l+s}{Add fourth line to foo.txt}\PY{l+s}{\PYZsq{}}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
[master a193ec0] Add fourth line to foo.txt
 1 file changed, 1 insertion(+)
    \end{Verbatim}


    \subsubsection{The log command}


    The \textbf{log} command prints an history of all the commits.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}24}]:} \PY{o}{\PYZpc{}\PYZpc{}}\PY{k}{bash}
         \PY{n}{git} \PY{n}{log}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
commit a193ec04e8add2de6b09d0b6f65b47ea4ccb6f47
Author: David Froger <david.froger@inria.fr>
Date:   Thu Jun 4 10:18:26 2015 +0200

    Add fourth line to foo.txt

commit 2e8215d1d0dc787d7080dff8e544444134bc38d2
Author: David Froger <david.froger@inria.fr>
Date:   Thu Jun 4 10:18:26 2015 +0200

    Third commit

commit 03ae0f2377799f15cc1988d24fe9f777e37b07f2
Author: David Froger <david.froger@inria.fr>
Date:   Thu Jun 4 10:18:25 2015 +0200

    Initial commit.
    \end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}25}]:} \PY{o}{\PYZpc{}\PYZpc{}}\PY{k}{bash}
         \PY{n}{git} \PY{n}{log} \PY{o}{\PYZhy{}}\PY{n}{p}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
commit a193ec04e8add2de6b09d0b6f65b47ea4ccb6f47
Author: David Froger <david.froger@inria.fr>
Date:   Thu Jun 4 10:18:26 2015 +0200

    Add fourth line to foo.txt

diff --git a/foo.txt b/foo.txt
index 6da4d3e..5028ae5 100644
--- a/foo.txt
+++ b/foo.txt
@@ -1,3 +1,4 @@
 First line
 Second line
 Third line
+Fourth line

commit 2e8215d1d0dc787d7080dff8e544444134bc38d2
Author: David Froger <david.froger@inria.fr>
Date:   Thu Jun 4 10:18:26 2015 +0200

    Third commit

diff --git a/foo.txt b/foo.txt
index 9649cde..6da4d3e 100644
--- a/foo.txt
+++ b/foo.txt
@@ -1 +1,3 @@
 First line
+Second line
+Third line

commit 03ae0f2377799f15cc1988d24fe9f777e37b07f2
Author: David Froger <david.froger@inria.fr>
Date:   Thu Jun 4 10:18:25 2015 +0200

    Initial commit.

diff --git a/foo.txt b/foo.txt
new file mode 100644
index 0000000..9649cde
--- /dev/null
+++ b/foo.txt
@@ -0,0 +1 @@
+First line
    \end{Verbatim}

    A common practice when writing commit messages is to start with a
one-line description of the commit, optionally followed by a longer
description which may be split into several paragraphs.

Another thing one may do when writing commit messages is to explain more
why the change is done than the change itself, since the change can be
figured out by studying the patch itself.


    \subsubsection{The checkout command}


    The \textbf{checkout} command updates files in the working tree to match
the version in the index or the specified tree. For example:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}26}]:} \PY{o}{\PYZpc{}\PYZpc{}}\PY{k}{bash}
         \PY{n}{git} \PY{n}{checkout} \PY{n}{master}\PY{o}{\PYZca{}}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
Note: checking out 'master\^{}'.

You are in 'detached HEAD' state. You can look around, make experimental
changes and commit them, and you can discard any commits you make in this
state without impacting any branches by performing another checkout.

If you want to create a new branch to retain commits you create, you may
do so (now or later) by using -b with the checkout command again. Example:

  git checkout -b new\_branch\_name

HEAD is now at 2e8215d\ldots Third commit
    \end{Verbatim}

    Will ask Git to set-up the working copy according to the content of
Git's database at commit master\^{}, namely one commit before master as
indicated by the \^{} postfix operator.

Let's verify:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}27}]:} \PY{o}{\PYZpc{}\PYZpc{}}\PY{k}{bash}
         \PY{n}{cat} \PY{n}{foo}\PY{o}{.}\PY{n}{txt}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
First line
Second line
Third line
    \end{Verbatim}

    And now let's restore the working copy as it was before this checkout:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}28}]:} \PY{o}{\PYZpc{}\PYZpc{}}\PY{k}{bash}
         \PY{n}{git} \PY{n}{checkout} \PY{n}{master}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
Previous HEAD position was 2e8215d\ldots Third commit
Switched to branch 'master'
    \end{Verbatim}

    And let's verify that this worked, too:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}29}]:} \PY{o}{\PYZpc{}\PYZpc{}}\PY{k}{bash}
         \PY{n}{cat} \PY{n}{foo}\PY{o}{.}\PY{n}{txt}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
First line
Second line
Third line
Fourth line
    \end{Verbatim}


    \subsubsection{More on commits}


    To take advantage of all the powerful features of Git, it is important
to understand what a \textbf{commit} actually is.

The first thing to know is that Git has stored in its database 1 commit
object,for each commit, each commit object containing a complete version
of the \texttt{foo.txt} file. - For the first commit, Git has stored in
its database a commit object containing \texttt{First line}. - For the
second commit, Git has stored in its database a commit object containing
not the difference between the two versions, but the whole file:
\texttt{First line} (hence duplicated in Git's database), and
\texttt{Second line}.

\begin{itemize}
\item
  After the second commit, \texttt{First line} \textbf{is} duplicated in
  the 2 different commit objects in Git's database.
\end{itemize}
Note that for performance, Git has the ability to efficiently compress
its database and handle differences only (especially during network
transfer), but the model is to store the whole content of files for each
commit, as opposed to some other revision control systems which only
store differences.

This yields a very simple model. A commit contains the directories and
files we have commited (called \texttt{tree} and \texttt{blob} in Git),
plus some metadata.

In Git, a commit object contains: - At least one parent commit (except
for the initial commit) - The (root) tree (which itself contains trees
and blobs). - The commit message. - The author. - The commit date.


    \subsubsection{The SHA-1}


    With Git it is not possible to assign integer numbers to commits in a
sequential way as is done in svn for instance, because Git's distributed
nature and branches make the very notion of linear sequence vanish.

Git uses the \textbf{SHA-1} cryptographic hash function to identify each
object (\textbf{commit}, \textbf{tree}, \textbf{blob}) with a hash
value. Such a hash value may look like the following one:
\texttt{0e1e060688a560015614cf7ec4b77d8a0df07c2f}.

The hash value is computed from the object's content. It is very
unlikely that two diferent commit objects have the same \textbf{SHA-1}
hash value. The likelihood of such collisions is so low that it is
generally considered to be 0, meaning that in practice it is considered
that having same SHA-1 hash and being the same commit are equivalent
propositions.

Each hash value identifies only one commit. It also identifies all the
directories and files that belong to the commit. Note that parent
commits are also part of the commit: two commits sharing the same files
and directories, but with different commit parents, will have different
hash values.

Note: - if two developpers create exactly the same commit on two
different computers, the hash value will be the same, - we know that two
commits are different by only comparing their hash values, - hash value
are very fast to compute: if a whole tree in a commit has not changed,
Git does not have to recompute its hash again.


    \subsubsection{Git branches}


    Suppose we now want to try developing a new feature in our code, while
continuing our previous work on \texttt{foo.txt}.

Git encourages creating a branch for this.

A branch is created with the \textbf{branch} command, followed by a
branch \textbf{name}:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}30}]:} \PY{o}{\PYZpc{}\PYZpc{}}\PY{k}{bash}
         \PY{n}{git} \PY{n}{branch} \PY{n}{bar}
\end{Verbatim}

    Without any argument, the \textbf{branch} command lists all the branches
and marks the current one with an asterisk (git status also displays the
current branch).

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}31}]:} \PY{o}{\PYZpc{}\PYZpc{}}\PY{k}{bash}
         \PY{n}{git} \PY{n}{branch}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
bar
* master
    \end{Verbatim}

    The \textbf{checkout} command allows you to switch to another branch:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}32}]:} \PY{o}{\PYZpc{}\PYZpc{}}\PY{k}{bash}
         \PY{n}{git} \PY{n}{checkout} \PY{n}{bar}
         \PY{n}{git} \PY{n}{branch}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
* bar
  master
    \end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
Switched to branch 'bar'
    \end{Verbatim}

    It is very important to remember that git branch b creates branch b but
does not change the current branch. This is similar to Unix's mkdir
command which creates a new directory without changing the current
directory to the one it just created. To continue the analogy with Unix
commands, git checkout b changes the current branch in the same way cd
changes the current directory.

It is however common when creating a branch that the intention is to
switch to that branch right after it has been created and this is what
the git checkout -b command does. In other words, what had been achieved
in two steps before (namely git branch bar and git checkout bar) can be
achieved with just the following command: git checkout -b bar.

Now, let us develop different things in the two branches:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}33}]:} \PY{o}{\PYZpc{}\PYZpc{}}\PY{k}{bash}
         \PY{n}{echo} \PY{l+s}{\PYZsq{}}\PY{l+s}{First line}\PY{l+s}{\PYZsq{}} \PY{o}{\PYZgt{}} \PY{n}{bar}\PY{o}{.}\PY{n}{txt}
         \PY{n}{git} \PY{n}{add} \PY{n}{bar}\PY{o}{.}\PY{n}{txt}
         \PY{n}{git} \PY{n}{commit} \PY{o}{\PYZhy{}}\PY{n}{m} \PY{l+s}{\PYZsq{}}\PY{l+s}{First line of bar.txt}\PY{l+s}{\PYZsq{}}
         
         \PY{n}{echo} \PY{l+s}{\PYZsq{}}\PY{l+s}{Second line}\PY{l+s}{\PYZsq{}} \PY{o}{\PYZgt{}\PYZgt{}} \PY{n}{bar}\PY{o}{.}\PY{n}{txt}
         \PY{n}{git} \PY{n}{add} \PY{n}{bar}\PY{o}{.}\PY{n}{txt}
         \PY{n}{git} \PY{n}{commit} \PY{o}{\PYZhy{}}\PY{n}{m} \PY{l+s}{\PYZsq{}}\PY{l+s}{Second line of bar.txt}\PY{l+s}{\PYZsq{}}
         
         \PY{n}{git} \PY{n}{checkout} \PY{n}{master}
         \PY{n}{echo} \PY{l+s}{\PYZdq{}}\PY{l+s}{Fifth line}\PY{l+s}{\PYZdq{}} \PY{o}{\PYZgt{}\PYZgt{}} \PY{n}{foo}\PY{o}{.}\PY{n}{txt}
         \PY{n}{git} \PY{n}{add} \PY{n}{foo}\PY{o}{.}\PY{n}{txt}
         \PY{n}{git} \PY{n}{commit} \PY{o}{\PYZhy{}}\PY{n}{m}  \PY{l+s}{\PYZsq{}}\PY{l+s}{Fifth line of foo.txt}\PY{l+s}{\PYZsq{}}
         
         \PY{n}{echo} \PY{l+s}{\PYZdq{}}\PY{l+s}{Sixth line}\PY{l+s}{\PYZdq{}} \PY{o}{\PYZgt{}\PYZgt{}} \PY{n}{foo}\PY{o}{.}\PY{n}{txt}
         \PY{n}{git} \PY{n}{add} \PY{n}{foo}\PY{o}{.}\PY{n}{txt}
         \PY{n}{git} \PY{n}{commit} \PY{o}{\PYZhy{}}\PY{n}{m} \PY{l+s}{\PYZsq{}}\PY{l+s}{Sixth line of foo.txt}\PY{l+s}{\PYZsq{}}
         
         \PY{n}{git} \PY{n}{checkout} \PY{n}{bar}
         \PY{n}{echo} \PY{l+s}{\PYZsq{}}\PY{l+s}{Third line}\PY{l+s}{\PYZsq{}} \PY{o}{\PYZgt{}\PYZgt{}} \PY{n}{bar}\PY{o}{.}\PY{n}{txt}
         \PY{n}{git} \PY{n}{add} \PY{n}{bar}\PY{o}{.}\PY{n}{txt}
         \PY{n}{git} \PY{n}{commit} \PY{o}{\PYZhy{}}\PY{n}{m} \PY{l+s}{\PYZsq{}}\PY{l+s}{Third line of bar.txt}\PY{l+s}{\PYZsq{}}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
[bar cb6bf03] First line of bar.txt
 1 file changed, 1 insertion(+)
 create mode 100644 bar.txt
[bar 34a5d44] Second line of bar.txt
 1 file changed, 1 insertion(+)
[master b4acc1d] Fifth line of foo.txt
 1 file changed, 1 insertion(+)
[master 3093c76] Sixth line of foo.txt
 1 file changed, 1 insertion(+)
[bar 95385f1] Third line of bar.txt
 1 file changed, 1 insertion(+)
    \end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
Switched to branch 'master'
Switched to branch 'bar'
    \end{Verbatim}


    \subsubsection{The merge command}


    We merge the work of the two branches. More specifically, we merge the
\textbf{bar} branch into the \textbf{master} branch

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}34}]:} \PY{o}{\PYZpc{}\PYZpc{}}\PY{k}{bash}
         \PY{n}{git} \PY{n}{checkout} \PY{n}{master}
         \PY{n}{git} \PY{n}{merge} \PY{n}{bar}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
Merge made by the 'recursive' strategy.
 bar.txt |    3 +++
 1 file changed, 3 insertions(+)
 create mode 100644 bar.txt
    \end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
Switched to branch 'master'
    \end{Verbatim}

    Because there is no conflict, the merge is performed automatically. In
case of confict (same lines of a file modified in both branches): - the
merge operation stops, - the developper edits the conflicting files to
solve the conflict, - the developper commits the merged files.


    \subsubsection{What Git branches are}


    Edit the file \texttt{\ensuremath{\sim}} and add the content:

\begin{verbatim}
[alias]
  gr = log --graph --full-history --all --color --pretty=tformat:"%x1b[31m%h%x09%x1b[32m%d%x1b[0m%x20%s%x20%x1b[33m(%an)%x1b[0m"
\end{verbatim}
This adds a useful \textbf{gr} command to Git, that displays a colored
graph of the branches.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}35}]:} \PY{o}{\PYZpc{}\PYZpc{}}\PY{k}{bash}
         \PY{n}{git} \PY{n}{gr}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
*   {\color{red}32f06db	}{\color{green} (HEAD, master)} Merge branch 'bar' {\color{brown}(David Froger)}
{\color{red}|}{\color{green}\textbackslash{}}  
{\color{red}|} * {\color{red}95385f1	}{\color{green} (bar)} Third line of bar.txt {\color{brown}(David Froger)}
{\color{red}|} * {\color{red}34a5d44	}{\color{green}} Second line of bar.txt {\color{brown}(David Froger)}
{\color{red}|} * {\color{red}cb6bf03	}{\color{green}} First line of bar.txt {\color{brown}(David Froger)}
* {\color{green}|} {\color{red}3093c76	}{\color{green}} Sixth line of foo.txt {\color{brown}(David Froger)}
* {\color{green}|} {\color{red}b4acc1d	}{\color{green}} Fifth line of foo.txt {\color{brown}(David Froger)}
{\color{green}|}{\color{green}/}  
* {\color{red}a193ec0	}{\color{green}} Add fourth line to foo.txt {\color{brown}(David Froger)}
* {\color{red}2e8215d	}{\color{green}} Third commit {\color{brown}(David Froger)}
* {\color{red}03ae0f2	}{\color{green}} Initial commit. {\color{brown}(David Froger)}
    \end{Verbatim}

    All the commits form a chain, in which each commit is linked to its
parent(s).

Creating a branch means having two commits with the same parent, while
merging means creating a commit with two parents.

We can now give a simple definition of a branch: a symbolic name that
points to a commit with no children.

Two special branches are: - \textbf{master}, the original branch when a
repository is created. That's a branch like the others. - \textbf{HEAD},
the current branch, which is updated after each commit (like \$PWD in
Unix shells).

When a commit is checked out that is not the end of a branch (has
children), it is said that the repository is in ``detached head'' mode.
In that state, it is possible to create commits which will be linked to
tehe one that has been checked out, but it must be kept in mind that no
symbolic name (apart from HEAD) will be associated with the last commit,
so when HEAD moves to a different branch the repo wil have a branch with
no symbolic name associated to its tip and which may hence be
garbage-collected later by Git. It is however possible and easy to
associate a symbolic name with a commit at any time with the git branch
command.

Note: with this knowledge on commits and branches, some Git features not
demonstrated here will be easy to understand: - rebase - fast-forward -
tags (symbolic names which don't move, as opposed to branches)


    \subsection{Exercice}


    During the exercice, experiment with \texttt{git log}, and
\texttt{git status}, \texttt{git gr}, etc.

0- Initialize an empty Git repository.

    1- Create a script \texttt{main.py} with the following content, and
commit it.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}36}]:} \PY{c}{\PYZsh{}!/usr/bin/env python}
         
         \PY{k}{def} \PY{n+nf}{greet}\PY{p}{(}\PY{p}{)}\PY{p}{:}
             \PY{k}{print}\PY{p}{(}\PY{l+s}{\PYZdq{}}\PY{l+s}{Hello world!}\PY{l+s}{\PYZdq{}}\PY{p}{)}
         
         \PY{n}{greet}\PY{p}{(}\PY{p}{)}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
Hello world!
    \end{Verbatim}

    2- Modify the the script, commit it

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}37}]:} \PY{c}{\PYZsh{}!/usr/bin/env python}
         
         \PY{k}{def} \PY{n+nf}{greet}\PY{p}{(}\PY{n}{name}\PY{p}{)}\PY{p}{:}
             \PY{k}{print}\PY{p}{(}\PY{l+s}{\PYZdq{}}\PY{l+s}{Hello }\PY{l+s+si}{\PYZpc{}s}\PY{l+s}{!}\PY{l+s}{\PYZdq{}} \PY{o}{\PYZpc{}} \PY{n}{name}\PY{p}{)}
         
         \PY{n}{greet}\PY{p}{(}\PY{l+s}{\PYZdq{}}\PY{l+s}{Alice}\PY{l+s}{\PYZdq{}}\PY{p}{)}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
Hello Alice!
    \end{Verbatim}

    3- Modify and commit the script again.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}38}]:} \PY{c}{\PYZsh{}!/usr/bin/env python}
         \PY{k+kn}{import} \PY{n+nn}{sys}
         
         \PY{k}{def} \PY{n+nf}{greet}\PY{p}{(}\PY{n}{name}\PY{p}{)}\PY{p}{:}
             \PY{k}{print}\PY{p}{(}\PY{l+s}{\PYZdq{}}\PY{l+s}{Hello }\PY{l+s+si}{\PYZpc{}s}\PY{l+s}{!}\PY{l+s}{\PYZdq{}} \PY{o}{\PYZpc{}} \PY{n}{name}\PY{p}{)}
         
         \PY{k}{if} \PY{n+nb}{len}\PY{p}{(}\PY{n}{sys}\PY{o}{.}\PY{n}{argv}\PY{p}{)} \PY{o}{\PYZgt{}} \PY{l+m+mi}{1}\PY{p}{:}
             \PY{n}{greet}\PY{p}{(}\PY{n}{sys}\PY{o}{.}\PY{n}{argv}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{)}
         \PY{k}{else}\PY{p}{:}
             \PY{n}{sys}\PY{o}{.}\PY{n}{stderr}\PY{o}{.}\PY{n}{write}\PY{p}{(}\PY{l+s}{\PYZdq{}}\PY{l+s}{Usage: }\PY{l+s+si}{\PYZpc{}s}\PY{l+s}{ NAME}\PY{l+s+se}{\PYZbs{}n}\PY{l+s}{\PYZdq{}} \PY{o}{\PYZpc{}} \PY{n}{sys}\PY{o}{.}\PY{n}{argv}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{p}{)}
             \PY{n}{sys}\PY{o}{.}\PY{n}{exit}\PY{p}{(}\PY{l+m+mi}{1}\PY{p}{)}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
Hello -f!
    \end{Verbatim}

    4- In a branch \texttt{format\_name}, modify and commit the script:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}39}]:} \PY{c}{\PYZsh{}!/usr/bin/env python}
         \PY{k+kn}{import} \PY{n+nn}{sys}
         
         \PY{k}{def} \PY{n+nf}{greet}\PY{p}{(}\PY{n}{name}\PY{p}{)}\PY{p}{:}
             \PY{k}{print}\PY{p}{(}\PY{l+s}{\PYZdq{}}\PY{l+s}{Hello }\PY{l+s+si}{\PYZpc{}s}\PY{l+s}{!}\PY{l+s}{\PYZdq{}} \PY{o}{\PYZpc{}} \PY{n}{name}\PY{o}{.}\PY{n}{capitalize}\PY{p}{(}\PY{p}{)}\PY{p}{)}
         
         \PY{k}{if} \PY{n+nb}{len}\PY{p}{(}\PY{n}{sys}\PY{o}{.}\PY{n}{argv}\PY{p}{)} \PY{o}{\PYZgt{}} \PY{l+m+mi}{1}\PY{p}{:}
             \PY{n}{greet}\PY{p}{(}\PY{n}{sys}\PY{o}{.}\PY{n}{argv}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{)}
         \PY{k}{else}\PY{p}{:}
             \PY{n}{sys}\PY{o}{.}\PY{n}{stderr}\PY{o}{.}\PY{n}{write}\PY{p}{(}\PY{l+s}{\PYZdq{}}\PY{l+s}{Usage: }\PY{l+s+si}{\PYZpc{}s}\PY{l+s}{ NAME}\PY{l+s+se}{\PYZbs{}n}\PY{l+s}{\PYZdq{}} \PY{o}{\PYZpc{}} \PY{n}{sys}\PY{o}{.}\PY{n}{argv}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{p}{)}
             \PY{n}{sys}\PY{o}{.}\PY{n}{exit}\PY{p}{(}\PY{l+m+mi}{1}\PY{p}{)}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
Hello -f!
    \end{Verbatim}

    5- In the \texttt{master} branch, modify the script and commit:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}40}]:} \PY{c}{\PYZsh{}!/usr/bin/env python}
         \PY{k+kn}{import} \PY{n+nn}{sys}
         
         \PY{k}{def} \PY{n+nf}{greet}\PY{p}{(}\PY{n}{name}\PY{p}{)}\PY{p}{:}
             \PY{k}{print}\PY{p}{(}\PY{l+s}{\PYZdq{}}\PY{l+s}{Hello }\PY{l+s+si}{\PYZpc{}s}\PY{l+s}{! How are you?}\PY{l+s}{\PYZdq{}} \PY{o}{\PYZpc{}} \PY{n}{name}\PY{p}{)}
         
         \PY{k}{if} \PY{n+nb}{len}\PY{p}{(}\PY{n}{sys}\PY{o}{.}\PY{n}{argv}\PY{p}{)} \PY{o}{\PYZgt{}} \PY{l+m+mi}{1}\PY{p}{:}
             \PY{n}{greet}\PY{p}{(}\PY{n}{sys}\PY{o}{.}\PY{n}{argv}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{)}
         \PY{k}{else}\PY{p}{:}
             \PY{n}{sys}\PY{o}{.}\PY{n}{stderr}\PY{o}{.}\PY{n}{write}\PY{p}{(}\PY{l+s}{\PYZdq{}}\PY{l+s}{Usage: }\PY{l+s+si}{\PYZpc{}s}\PY{l+s}{ NAME}\PY{l+s+se}{\PYZbs{}n}\PY{l+s}{\PYZdq{}} \PY{o}{\PYZpc{}} \PY{n}{sys}\PY{o}{.}\PY{n}{argv}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{p}{)}
             \PY{n}{sys}\PY{o}{.}\PY{n}{exit}\PY{p}{(}\PY{l+m+mi}{1}\PY{p}{)}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
Hello -f! How are you?
    \end{Verbatim}

    6- Merge the \texttt{format\_name} branch. You will have to resolve a
conflict, and the commit


    \subsection{Centralized (à la cvs/svn) version control}


    Now that we have learned how to work with a single Git repository, we
will learn how to send/receive commits between two Git repositories

In this section, we will assume a workflow with two developpers: Alice
and Bob. Both of them have their own repository on their computer: -
Alice's repository A on her computer, - Bob's repository B on his
computer.

and a central repository on a computer which both Alice and Bob can
communicate with: - central repository C on a ``server''.

For simplicity, we will demonstrate the commands on the same machine,
using Git \textbf{file://} protocol. However, Git commands would be
\textbf{exactly the same}, but using instead the \textbf{ssh://} or
\textbf{https://} protocols.

Note that configuring a ``server'' machine to host a Git repository and
managing user permissions, backup, availability, Web views of the
repository, etc. is not easy. Forges like \textbf{Inria's GForge},
\textbf{GitHub}, \textbf{Bitbucket}, \textbf{Gitorious} should be
preferred.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}41}]:} \PY{n}{changedir}\PY{p}{(}\PY{l+s}{\PYZsq{}}\PY{l+s}{\PYZsq{}}\PY{p}{)}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
We are in directory /home/ROCQ/sedrocq/froger/git-training
    \end{Verbatim}


    \subsubsection{The --bare option of the init command}


    We start by creating a central repository.

There is a subtlety. Suppose we create a git repository in
\texttt{\ensuremath{\sim}} and that someone else edits files in this Git
repository.

It is possible that someone else sends commits (in Git, this is called
\textbf{push}) to this repository, which would be stored in
\texttt{\ensuremath{\sim}}. Then Git's database and working copy would
differ.

To avoid this situtation, Git provides the \textbf{--bare} option to
\textbf{init}. It creates a Git repository, but without a working copy.
Nobody can \textbf{commit} directly into this repository, but only
\textbf{push} commits.

Never \textbf{push} commits to a Git repository that is not
\textbf{bare}, to avoid inconsistencies with its working copy.

By convention, \textbf{bare} repositories are suffixed with
\textbf{.git}, even if it is not necessary.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}42}]:} \PY{o}{\PYZpc{}\PYZpc{}}\PY{k}{bash}
         \PY{n}{git} \PY{n}{init} \PY{o}{\PYZhy{}}\PY{o}{\PYZhy{}}\PY{n}{bare} \PY{n}{central}\PY{o}{.}\PY{n}{git}
         \PY{n}{ls} \PY{o}{\PYZhy{}}\PY{n}{l} \PY{n}{central}\PY{o}{.}\PY{n}{git}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
Initialized empty Git repository in /nas/home3/f/froger/git-training/central.git/
total 28
drwxr-xr-x 2 froger sed 4096 Jun  4 10:18 branches
-rw-r--r-- 1 froger sed   66 Jun  4 10:18 config
-rw-r--r-- 1 froger sed   73 Jun  4 10:18 description
-rw-r--r-- 1 froger sed   23 Jun  4 10:18 HEAD
drwxr-xr-x 2 froger sed 4096 Jun  4 10:18 hooks
drwxr-xr-x 2 froger sed 4096 Jun  4 10:18 info
drwxr-xr-x 4 froger sed 4096 Jun  4 10:18 objects
drwxr-xr-x 4 froger sed 4096 Jun  4 10:18 refs
    \end{Verbatim}

    Alice clones the central repository:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}43}]:} \PY{o}{\PYZpc{}\PYZpc{}}\PY{k}{bash}
         \PY{n}{git} \PY{n}{clone} \PY{n+nb}{file}\PY{p}{:}\PY{o}{/}\PY{o}{/}\PY{err}{\PYZdl{}}\PY{n}{PWD}\PY{o}{/}\PY{n}{central}\PY{o}{.}\PY{n}{git} \PY{n}{alice}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
Cloning into 'alice'\ldots
    \end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
warning: You appear to have cloned an empty repository.
    \end{Verbatim}

    Alice enters her Git repository and configures her name and email for
that repository (we assume here she didn't do it at the global level, to
keep all the examples self-contained):

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}44}]:} \PY{n}{changedir}\PY{p}{(}\PY{l+s}{\PYZsq{}}\PY{l+s}{alice}\PY{l+s}{\PYZsq{}}\PY{p}{)}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
We are in directory /home/ROCQ/sedrocq/froger/git-training/alice
    \end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}45}]:} \PY{o}{\PYZpc{}\PYZpc{}}\PY{k}{bash}
         \PY{n}{git} \PY{n}{config} \PY{o}{\PYZhy{}}\PY{o}{\PYZhy{}}\PY{n}{local} \PY{n}{user}\PY{o}{.}\PY{n}{name} \PY{l+s}{\PYZdq{}}\PY{l+s}{Alice}\PY{l+s}{\PYZdq{}}
         \PY{n}{git} \PY{n}{config} \PY{o}{\PYZhy{}}\PY{o}{\PYZhy{}}\PY{n}{local} \PY{n}{user}\PY{o}{.}\PY{n}{email} \PY{n}{alice}\PY{n+nd}{@inria.fr}
\end{Verbatim}


    \subsubsection{The remote command}


    Without argument, the \emph{remote} command lists the \textbf{remote}
repositories Git knows about:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}46}]:} \PY{o}{\PYZpc{}\PYZpc{}}\PY{k}{bash}
         \PY{n}{git} \PY{n}{remote}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
origin
    \end{Verbatim}

    When the central repository has been cloned, Git has given it the name
\textbf{origin}, by convention.

Later, we will learn how to register additionnal remote repositories.

Alice works and commits into her repository:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}47}]:} \PY{o}{\PYZpc{}\PYZpc{}}\PY{k}{bash}
         \PY{n}{echo} \PY{l+s}{\PYZsq{}}\PY{l+s}{First line}\PY{l+s}{\PYZsq{}} \PY{o}{\PYZgt{}} \PY{n}{foo}\PY{o}{.}\PY{n}{txt}
         \PY{n}{git} \PY{n}{add} \PY{n}{foo}\PY{o}{.}\PY{n}{txt}
         \PY{n}{git} \PY{n}{commit} \PY{o}{\PYZhy{}}\PY{n}{m} \PY{l+s}{\PYZsq{}}\PY{l+s}{First line of foo.txt}\PY{l+s}{\PYZsq{}}
         
         \PY{n}{echo} \PY{l+s}{\PYZsq{}}\PY{l+s}{Second line}\PY{l+s}{\PYZsq{}} \PY{o}{\PYZgt{}\PYZgt{}} \PY{n}{foo}\PY{o}{.}\PY{n}{txt}
         \PY{n}{git} \PY{n}{add} \PY{n}{foo}\PY{o}{.}\PY{n}{txt}
         \PY{n}{git} \PY{n}{commit} \PY{o}{\PYZhy{}}\PY{n}{m} \PY{l+s}{\PYZsq{}}\PY{l+s}{Second line of foo.txt}\PY{l+s}{\PYZsq{}}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
[master (root-commit) 5d6da4a] First line of foo.txt
 1 file changed, 1 insertion(+)
 create mode 100644 foo.txt
[master e25907a] Second line of foo.txt
 1 file changed, 1 insertion(+)
    \end{Verbatim}


    \subsubsection{The push command}


    Now, Alice wants to send her commits to the central repository, so that
Bob can get them.

To do so, she uses the \textbf{push} command, whose arguments are:

\begin{verbatim}
git push <remote_name> <local_branch>:<remote_branch>
\end{verbatim}
The remote\_name is \textbf{origin}, Alice pushes the \textbf{master}
branch of her repository to the \textbf{master} branch of the central
repository:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}48}]:} \PY{o}{\PYZpc{}\PYZpc{}}\PY{k}{bash}
         \PY{n}{git} \PY{n}{push} \PY{n}{origin} \PY{n}{master}\PY{p}{:}\PY{n}{master}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
To file:///nas/home3/f/froger/git-training/central.git
 * [new branch]      master -> master
    \end{Verbatim}

    Bob now clones the central repository too, enters it and configures his
name and email:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}49}]:} \PY{n}{changedir}\PY{p}{(}\PY{l+s}{\PYZsq{}}\PY{l+s}{\PYZsq{}}\PY{p}{)}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
We are in directory /home/ROCQ/sedrocq/froger/git-training
    \end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}50}]:} \PY{o}{\PYZpc{}\PYZpc{}}\PY{k}{bash}
         \PY{n}{git} \PY{n}{clone} \PY{n+nb}{file}\PY{p}{:}\PY{o}{/}\PY{o}{/}\PY{err}{\PYZdl{}}\PY{n}{PWD}\PY{o}{/}\PY{n}{central}\PY{o}{.}\PY{n}{git} \PY{n}{bob}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
Cloning into 'bob'\ldots
    \end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}51}]:} \PY{n}{changedir}\PY{p}{(}\PY{l+s}{\PYZsq{}}\PY{l+s}{bob}\PY{l+s}{\PYZsq{}}\PY{p}{)}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
We are in directory /home/ROCQ/sedrocq/froger/git-training/bob
    \end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}52}]:} \PY{o}{\PYZpc{}\PYZpc{}}\PY{k}{bash}
         \PY{n}{git} \PY{n}{config} \PY{o}{\PYZhy{}}\PY{o}{\PYZhy{}}\PY{n}{local} \PY{n}{user}\PY{o}{.}\PY{n}{name} \PY{l+s}{\PYZdq{}}\PY{l+s}{Bob}\PY{l+s}{\PYZdq{}}
         \PY{n}{git} \PY{n}{config} \PY{o}{\PYZhy{}}\PY{o}{\PYZhy{}}\PY{n}{local} \PY{n}{user}\PY{o}{.}\PY{n}{email} \PY{n}{bob}\PY{n+nd}{@inria.fr}
\end{Verbatim}

    Doing so, Bob fetches Alice's work.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}53}]:} \PY{o}{\PYZpc{}\PYZpc{}}\PY{k}{bash}
         \PY{n}{git} \PY{n}{log}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
commit e25907af8eaeb28bf671ee1a3ce10c65884880c2
Author: Alice <alice@inria.fr>
Date:   Thu Jun 4 10:18:28 2015 +0200

    Second line of foo.txt

commit 5d6da4af17f62dcee5ded8bf4f873483db4bf1e8
Author: Alice <alice@inria.fr>
Date:   Thu Jun 4 10:18:28 2015 +0200

    First line of foo.txt
    \end{Verbatim}

    Bob makes some changes, commits and pushes:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}54}]:} \PY{o}{\PYZpc{}\PYZpc{}}\PY{k}{bash}
         \PY{n}{echo} \PY{l+s}{\PYZdq{}}\PY{l+s}{Third line}\PY{l+s}{\PYZdq{}} \PY{o}{\PYZgt{}\PYZgt{}} \PY{n}{foo}\PY{o}{.}\PY{n}{txt}
         \PY{n}{git} \PY{n}{add} \PY{n}{foo}\PY{o}{.}\PY{n}{txt}
         \PY{n}{git} \PY{n}{commit} \PY{o}{\PYZhy{}}\PY{n}{m} \PY{l+s}{\PYZdq{}}\PY{l+s}{Third line to foo.txt}\PY{l+s}{\PYZdq{}}
         \PY{n}{git} \PY{n}{push} \PY{n}{origin} \PY{n}{master}\PY{p}{:}\PY{n}{master}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
[master f08edac] Third line to foo.txt
 1 file changed, 1 insertion(+)
    \end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
To file:///nas/home3/f/froger/git-training/central.git
   e25907a..f08edac  master -> master
    \end{Verbatim}


    \subsubsection{The fetch command}


    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}55}]:} \PY{n}{changedir}\PY{p}{(}\PY{l+s}{\PYZsq{}}\PY{l+s}{alice}\PY{l+s}{\PYZsq{}}\PY{p}{)}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
We are in directory /home/ROCQ/sedrocq/froger/git-training/alice
    \end{Verbatim}

    Alice wants to get Bob's commits. She uses the \textbf{fetch} command,
which donwloads all the commits of all branches from a remote
repository.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}56}]:} \PY{o}{\PYZpc{}\PYZpc{}}\PY{k}{bash}
         \PY{n}{git} \PY{n}{fetch} \PY{n}{origin}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
From file:///nas/home3/f/froger/git-training/central
   e25907a..f08edac  master     -> origin/master
    \end{Verbatim}


    \subsubsection{Remote branches}


    The git \textbf{branch} command lists all branches of Alice's
repository, also known as local branches:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}57}]:} \PY{o}{\PYZpc{}\PYZpc{}}\PY{k}{bash}
         \PY{n}{git} \PY{n}{branch}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
* master
    \end{Verbatim}

    But where are the \textbf{central} repository branches which have just
been fetched?

Adding the \textbf{-a} option to the \textbf{branch} command reveals
them:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}58}]:} \PY{o}{\PYZpc{}\PYZpc{}}\PY{k}{bash}
         \PY{n}{git} \PY{n}{branch} \PY{o}{\PYZhy{}}\PY{n}{a}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
* master
  remotes/origin/master
    \end{Verbatim}

    \texttt{remotes/central/master.git} is called a \textbf{remote branch}.

A \textbf{remote branch} is a read-only branch that reflects the state
of a branch of a remote repository. If the branch changes on the remote
repository, use \textbf{fetch} again to refresh it.

Note: to see only remote branches rather than all branches one can use
the -r flag instead of -a:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}59}]:} \PY{o}{\PYZpc{}\PYZpc{}\PYZpc{}}\PY{k}{bash}
         \PY{n}{git} \PY{n}{branch} \PY{o}{\PYZhy{}}\PY{n}{r}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
origin/master
    \end{Verbatim}

    To get all commits of \texttt{remotes/central/master} \textbf{remote
branch} into the \textbf{master} branch, merge it:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}60}]:} \PY{o}{\PYZpc{}\PYZpc{}}\PY{k}{bash}
         \PY{n}{git} \PY{n}{merge} \PY{n}{remotes}\PY{o}{/}\PY{n}{origin}\PY{o}{/}\PY{n}{master}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
Updating e25907a..f08edac
Fast-forward
 foo.txt |    1 +
 1 file changed, 1 insertion(+)
    \end{Verbatim}

    Note: \textbf{fetch} and \textbf{merge} operations can be accomplished
in one command, \textbf{pull}:

\begin{verbatim}
git pull <remote_name> <remote_branch>:<local_branch>
\end{verbatim}


    \subsubsection{Pushing a (feature) branch}


    While Alice and Bob are working on the master branch, Alice wants to
develop an experimental feature.

She creates a branch for this, and works in it:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}61}]:} \PY{o}{\PYZpc{}\PYZpc{}}\PY{k}{bash}
         \PY{n}{git} \PY{n}{checkout} \PY{o}{\PYZhy{}}\PY{n}{b} \PY{n}{exp}
         
         \PY{n}{echo} \PY{l+s}{\PYZdq{}}\PY{l+s}{First line}\PY{l+s}{\PYZdq{}} \PY{o}{\PYZgt{}} \PY{n}{bar}\PY{o}{.}\PY{n}{txt}
         \PY{n}{git} \PY{n}{add} \PY{n}{bar}\PY{o}{.}\PY{n}{txt}
         \PY{n}{git} \PY{n}{commit} \PY{o}{\PYZhy{}}\PY{n}{m} \PY{l+s}{\PYZsq{}}\PY{l+s}{First line of bar.txt}\PY{l+s}{\PYZsq{}}
         
         \PY{n}{echo} \PY{l+s}{\PYZdq{}}\PY{l+s}{Second line}\PY{l+s}{\PYZdq{}} \PY{o}{\PYZgt{}\PYZgt{}} \PY{n}{bar}\PY{o}{.}\PY{n}{txt}
         \PY{n}{git} \PY{n}{add} \PY{n}{bar}\PY{o}{.}\PY{n}{txt}
         \PY{n}{git} \PY{n}{commit} \PY{o}{\PYZhy{}}\PY{n}{m} \PY{l+s}{\PYZdq{}}\PY{l+s}{Second line in bar.txt}\PY{l+s}{\PYZdq{}}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
[exp 152052b] First line of bar.txt
 1 file changed, 1 insertion(+)
 create mode 100644 bar.txt
[exp c6d459f] Second line in bar.txt
 1 file changed, 1 insertion(+)
    \end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
Switched to a new branch 'exp'
    \end{Verbatim}

    Alice then pushes her branch to a similarly named branch of the central
repository:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}62}]:} \PY{o}{\PYZpc{}\PYZpc{}}\PY{k}{bash}
         \PY{n}{git} \PY{n}{push} \PY{n}{origin} \PY{n}{exp}\PY{p}{:}\PY{n}{exp}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
To file:///nas/home3/f/froger/git-training/central.git
 * [new branch]      exp -> exp
    \end{Verbatim}


    \subsubsection{Tracking branch}


    At the same time, Bob has worked on the master branch:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}63}]:} \PY{n}{changedir}\PY{p}{(}\PY{l+s}{\PYZsq{}}\PY{l+s}{bob}\PY{l+s}{\PYZsq{}}\PY{p}{)}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
We are in directory /home/ROCQ/sedrocq/froger/git-training/bob
    \end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}64}]:} \PY{o}{\PYZpc{}\PYZpc{}}\PY{k}{bash}
         \PY{n}{echo} \PY{l+s}{\PYZdq{}}\PY{l+s}{Third line}\PY{l+s}{\PYZdq{}} \PY{o}{\PYZgt{}\PYZgt{}} \PY{n}{foo}\PY{o}{.}\PY{n}{txt}
         \PY{n}{git} \PY{n}{add} \PY{n}{foo}\PY{o}{.}\PY{n}{txt}
         \PY{n}{git} \PY{n}{commit} \PY{o}{\PYZhy{}}\PY{n}{m} \PY{l+s}{\PYZdq{}}\PY{l+s}{Third line in foo.txt}\PY{l+s}{\PYZdq{}}
         
         \PY{n}{echo} \PY{l+s}{\PYZdq{}}\PY{l+s}{Fourth line}\PY{l+s}{\PYZdq{}} \PY{o}{\PYZgt{}\PYZgt{}} \PY{n}{foo}\PY{o}{.}\PY{n}{txt}
         \PY{n}{git} \PY{n}{add} \PY{n}{foo}\PY{o}{.}\PY{n}{txt}
         \PY{n}{git} \PY{n}{commit} \PY{o}{\PYZhy{}}\PY{n}{m} \PY{l+s}{\PYZdq{}}\PY{l+s}{Fourth line in foo.txt}\PY{l+s}{\PYZdq{}}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
[master bbb36ce] Third line in foo.txt
 1 file changed, 1 insertion(+)
[master 2420c80] Fourth line in foo.txt
 1 file changed, 1 insertion(+)
    \end{Verbatim}

    Bob wants to see Alice's work on the \texttt{exp} branch. He fetches all
branches of the central repository:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}65}]:} \PY{o}{\PYZpc{}\PYZpc{}}\PY{k}{bash}
         \PY{n}{git} \PY{n}{fetch}
         \PY{n}{git} \PY{n}{branch} \PY{o}{\PYZhy{}}\PY{n}{r}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
origin/HEAD -> origin/master
  origin/exp
  origin/master
    \end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
From file:///nas/home3/f/froger/git-training/central
 * [new branch]      exp        -> origin/exp
    \end{Verbatim}

    Bob has remote branch \texttt{central/exp}, but how to work with it?

Adding the \textbf{--track} option to the \textbf{checkout} command
makes Git create a \textbf{tracking branch}:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}66}]:} \PY{o}{\PYZpc{}\PYZpc{}}\PY{k}{bash}
         \PY{n}{git} \PY{n}{checkout} \PY{o}{\PYZhy{}}\PY{o}{\PYZhy{}}\PY{n}{track} \PY{n}{origin}\PY{o}{/}\PY{n}{exp}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
Branch exp set up to track remote branch exp from origin.
    \end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
Switched to a new branch 'exp'
    \end{Verbatim}

    A tracking branch is our local copy of a remote branch. Unlike the
remote branch, we have write access to it.

Tracking branches can also be used to call the \textbf{pull} and
\textbf{push} commands without arguments.

    Note that Alice and Bob can work on the \texttt{exp} branch without
changing anything to the \texttt{master} branch. - if \texttt{exp} was
not a good idea, the branch can be dropped, - if \texttt{exp} is a good
idea, it may be merged into the \texttt{master} branch.


    \subsubsection{Visualizing branches}


    Bob helps Alice to develop the \texttt{exp} branch by making a new
commit:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}67}]:} \PY{o}{\PYZpc{}\PYZpc{}}\PY{k}{bash}
         \PY{n}{echo} \PY{l+s}{\PYZdq{}}\PY{l+s}{Third line}\PY{l+s}{\PYZdq{}} \PY{o}{\PYZgt{}\PYZgt{}} \PY{n}{bar}\PY{o}{.}\PY{n}{txt}
         \PY{n}{git} \PY{n}{add} \PY{n}{bar}\PY{o}{.}\PY{n}{txt}
         \PY{n}{git} \PY{n}{commit} \PY{o}{\PYZhy{}}\PY{n}{m} \PY{l+s}{\PYZdq{}}\PY{l+s}{Third line in bar.txt}\PY{l+s}{\PYZdq{}}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
[exp ac69ae8] Third line in bar.txt
 1 file changed, 1 insertion(+)
    \end{Verbatim}

    At this point, it is instructive to visualize the different branches:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}68}]:} \PY{o}{\PYZpc{}\PYZpc{}}\PY{k}{bash}
         \PY{n}{git} \PY{n}{gr}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
* {\color{red}ac69ae8	}{\color{green} (HEAD, exp)} Third line in bar.txt {\color{brown}(Bob)}
* {\color{red}c6d459f	}{\color{green} (origin/exp)} Second line in bar.txt {\color{brown}(Alice)}
* {\color{red}152052b	}{\color{green}} First line of bar.txt {\color{brown}(Alice)}
{\color{red}|} * {\color{red}2420c80	}{\color{green} (master)} Fourth line in foo.txt {\color{brown}(Bob)}
{\color{red}|} * {\color{red}bbb36ce	}{\color{green}} Third line in foo.txt {\color{brown}(Bob)}
{\color{red}|}{\color{red}/}  
* {\color{red}f08edac	}{\color{green} (origin/master, origin/HEAD)} Third line to foo.txt {\color{brown}(Bob)}
* {\color{red}e25907a	}{\color{green}} Second line of foo.txt {\color{brown}(Alice)}
* {\color{red}5d6da4a	}{\color{green}} First line of foo.txt {\color{brown}(Alice)}
    \end{Verbatim}

    We note that: - Bob's master branch has 2 more commits than the central
one. - Bob master branch has 1 more commit that the central one.

    The verbose option of \textbf{branch} is useful to see tracking
branches:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}69}]:} \PY{o}{\PYZpc{}\PYZpc{}}\PY{k}{bash}
         \PY{n}{git} \PY{n}{branch} \PY{o}{\PYZhy{}}\PY{n}{avv}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
* exp                   ac69ae8 [origin/exp: ahead 1] Third line in bar.txt
  master                2420c80 [origin/master: ahead 2] Fourth line in foo.txt
  remotes/origin/HEAD   -> origin/master
  remotes/origin/exp    c6d459f Second line in bar.txt
  remotes/origin/master f08edac Third line to foo.txt
    \end{Verbatim}

    Bob pushes the commits of the two branches.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}70}]:} \PY{o}{\PYZpc{}\PYZpc{}}\PY{k}{bash}
         \PY{n}{git} \PY{n}{push} \PY{n}{origin} \PY{n}{exp}\PY{p}{:}\PY{n}{exp}
         \PY{n}{git} \PY{n}{push} \PY{n}{origin} \PY{n}{master}\PY{p}{:}\PY{n}{master}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
To file:///nas/home3/f/froger/git-training/central.git
   c6d459f..ac69ae8  exp -> exp
To file:///nas/home3/f/froger/git-training/central.git
   f08edac..2420c80  master -> master
    \end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}71}]:} \PY{o}{\PYZpc{}\PYZpc{}}\PY{k}{bash}
         \PY{n}{git} \PY{n}{checkout} \PY{n}{master}
         
         \PY{n}{git} \PY{n}{push} \PY{n}{origin} \PY{n}{master}\PY{p}{:}\PY{n}{master}
         \PY{n}{git} \PY{n}{gr}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
* {\color{red}ac69ae8	}{\color{green} (origin/exp, exp)} Third line in bar.txt {\color{brown}(Bob)}
* {\color{red}c6d459f	}{\color{green}} Second line in bar.txt {\color{brown}(Alice)}
* {\color{red}152052b	}{\color{green}} First line of bar.txt {\color{brown}(Alice)}
{\color{red}|} * {\color{red}2420c80	}{\color{green} (HEAD, origin/master, origin/HEAD, master)} Fourth line in foo.txt {\color{brown}(Bob)}
{\color{red}|} * {\color{red}bbb36ce	}{\color{green}} Third line in foo.txt {\color{brown}(Bob)}
{\color{red}|}{\color{red}/}  
* {\color{red}f08edac	}{\color{green}} Third line to foo.txt {\color{brown}(Bob)}
* {\color{red}e25907a	}{\color{green}} Second line of foo.txt {\color{brown}(Alice)}
* {\color{red}5d6da4a	}{\color{green}} First line of foo.txt {\color{brown}(Alice)}
    \end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
Switched to branch 'master'
Everything up-to-date
    \end{Verbatim}

    Finally, the \texttt{exp} branch is merged into master. The merge commit
is pushed to the central repository, and the exp branch is deleted:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}72}]:} \PY{o}{\PYZpc{}\PYZpc{}}\PY{k}{bash}
         \PY{c}{\PYZsh{} We already are in the master branch}
         
         \PY{n}{git} \PY{n}{merge} \PY{n}{exp}
         \PY{n}{git} \PY{n}{push} \PY{n}{origin} \PY{n}{master}\PY{p}{:}\PY{n}{master}
         \PY{n}{git} \PY{n}{branch} \PY{o}{\PYZhy{}}\PY{n}{d} \PY{n}{exp}
         \PY{n}{git} \PY{n}{gr}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
Merge made by the 'recursive' strategy.
 bar.txt |    3 +++
 1 file changed, 3 insertions(+)
 create mode 100644 bar.txt
Deleted branch exp (was ac69ae8).
*   {\color{red}5a1c308	}{\color{green} (HEAD, origin/master, origin/HEAD, master)} Merge branch 'exp' {\color{brown}(Bob)}
{\color{red}|}{\color{green}\textbackslash{}}  
{\color{red}|} * {\color{red}ac69ae8	}{\color{green} (origin/exp)} Third line in bar.txt {\color{brown}(Bob)}
{\color{red}|} * {\color{red}c6d459f	}{\color{green}} Second line in bar.txt {\color{brown}(Alice)}
{\color{red}|} * {\color{red}152052b	}{\color{green}} First line of bar.txt {\color{brown}(Alice)}
* {\color{green}|} {\color{red}2420c80	}{\color{green}} Fourth line in foo.txt {\color{brown}(Bob)}
* {\color{green}|} {\color{red}bbb36ce	}{\color{green}} Third line in foo.txt {\color{brown}(Bob)}
{\color{green}|}{\color{green}/}  
* {\color{red}f08edac	}{\color{green}} Third line to foo.txt {\color{brown}(Bob)}
* {\color{red}e25907a	}{\color{green}} Second line of foo.txt {\color{brown}(Alice)}
* {\color{red}5d6da4a	}{\color{green}} First line of foo.txt {\color{brown}(Alice)}
    \end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
To file:///nas/home3/f/froger/git-training/central.git
   2420c80..5a1c308  master -> master
    \end{Verbatim}


    \subsection{Distributed workflow}


    Committing to a central repository is okay for small teams where
developpers know and trust each other. For larger projects, though, it
is blocking and dangerous to give write access to the project's main
repository to an external contributor.

Since Git is a distributed revision control system, clloning a
repository means creating a copy of that repository that has exactly as
much information. This opens the road to a workflow different rom the
previous one, where each developer has a public repository from which
everybody can read. When this developer wants to share code, he/she
pushes the code to be shared to his/her public repository and informs
the maintainers of the project that there is some code available that
may beintegrated to the project. The maintainers review the code and, if
they find it useful, integrate it to the project's main code base.

This workflow is made possible by the way Git has been designed. The
GitHub platform provides two mechanisms (fork and pull request) that
help developers adopting this workflow, but the workflow itself relies
only on Git features and does not require GitHub to be implemented.

When a developper wants to contribute to a project, he/she forks the
original bare repository. It means that the developper gets his own bare
repository. In this repository, he develops a feature in a branch. When
the work is done, he asks an administrator to pull the feature branch
from his repository to the master branch of the project's main
repository.

In GitHub terminology, this is called a \textbf{pull request}.

Let us see this in practice by adding \textbf{Emma} as a developper to
our previous example.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}73}]:} \PY{n}{changedir}\PY{p}{(}\PY{l+s}{\PYZsq{}}\PY{l+s}{\PYZsq{}}\PY{p}{)}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
We are in directory /home/ROCQ/sedrocq/froger/git-training
    \end{Verbatim}

    Emma starts by forking the central repository to her own bare
repository.

Note: this is a functionnality provided out of the box by GitHub.

Then Emma clones her bare public repository.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}74}]:} \PY{o}{\PYZpc{}\PYZpc{}}\PY{k}{bash}
         \PY{n}{git} \PY{n}{clone} \PY{o}{\PYZhy{}}\PY{o}{\PYZhy{}}\PY{n}{bare} \PY{n}{central}\PY{o}{.}\PY{n}{git} \PY{n}{central}\PY{o}{\PYZhy{}}\PY{n}{emma}\PY{o}{\PYZhy{}}\PY{n}{fork}\PY{o}{.}\PY{n}{git}
         
         \PY{n}{git} \PY{n}{clone} \PY{n}{central}\PY{o}{\PYZhy{}}\PY{n}{emma}\PY{o}{\PYZhy{}}\PY{n}{fork}\PY{o}{.}\PY{n}{git} \PY{n}{emma}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
Cloning into bare repository 'central-emma-fork.git'\ldots
done.
Cloning into 'emma'\ldots
done.
    \end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}75}]:} \PY{n}{changedir}\PY{p}{(}\PY{l+s}{\PYZsq{}}\PY{l+s}{emma}\PY{l+s}{\PYZsq{}}\PY{p}{)}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
We are in directory /home/ROCQ/sedrocq/froger/git-training/emma
    \end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}76}]:} \PY{o}{\PYZpc{}\PYZpc{}}\PY{k}{bash}
         \PY{n}{git} \PY{n}{config} \PY{o}{\PYZhy{}}\PY{o}{\PYZhy{}}\PY{n}{local} \PY{n}{user}\PY{o}{.}\PY{n}{name} \PY{l+s}{\PYZdq{}}\PY{l+s}{Emma}\PY{l+s}{\PYZdq{}}
         \PY{n}{git} \PY{n}{config} \PY{o}{\PYZhy{}}\PY{o}{\PYZhy{}}\PY{n}{local} \PY{n}{user}\PY{o}{.}\PY{n}{email} \PY{n}{emma}\PY{n+nd}{@inria.fr}
\end{Verbatim}

    Emma creates a topic branch, works on it, and pushes it to her public
repository:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}77}]:} \PY{o}{\PYZpc{}\PYZpc{}}\PY{k}{bash}
         \PY{n}{git} \PY{n}{checkout} \PY{o}{\PYZhy{}}\PY{n}{b} \PY{n}{baz}
         
         \PY{n}{echo} \PY{l+s}{\PYZdq{}}\PY{l+s}{First line}\PY{l+s}{\PYZdq{}} \PY{o}{\PYZgt{}} \PY{n}{baz}\PY{o}{.}\PY{n}{txt}
         \PY{n}{git} \PY{n}{add} \PY{n}{baz}\PY{o}{.}\PY{n}{txt}
         \PY{n}{git} \PY{n}{commit} \PY{o}{\PYZhy{}}\PY{n}{m} \PY{l+s}{\PYZsq{}}\PY{l+s}{First line in baz.txt}\PY{l+s}{\PYZsq{}}
         
         \PY{n}{echo} \PY{l+s}{\PYZdq{}}\PY{l+s}{Second line}\PY{l+s}{\PYZdq{}} \PY{o}{\PYZgt{}\PYZgt{}} \PY{n}{baz}\PY{o}{.}\PY{n}{txt}
         \PY{n}{git} \PY{n}{add} \PY{n}{baz}\PY{o}{.}\PY{n}{txt}
         \PY{n}{git} \PY{n}{commit} \PY{o}{\PYZhy{}}\PY{n}{m} \PY{l+s}{\PYZsq{}}\PY{l+s}{Second line in baz.txt}\PY{l+s}{\PYZsq{}}
         
         \PY{n}{git} \PY{n}{push} \PY{n}{origin} \PY{n}{baz}\PY{p}{:}\PY{n}{baz}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
[baz b404311] First line in baz.txt
 1 file changed, 1 insertion(+)
 create mode 100644 baz.txt
[baz 80e082f] Second line in baz.txt
 1 file changed, 1 insertion(+)
    \end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
Switched to a new branch 'baz'
To /nas/home3/f/froger/git-training/central-emma-fork.git
 * [new branch]      baz -> baz
    \end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}78}]:} \PY{n}{changedir}\PY{p}{(}\PY{l+s}{\PYZsq{}}\PY{l+s}{alice}\PY{l+s}{\PYZsq{}}\PY{p}{)}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
We are in directory /home/ROCQ/sedrocq/froger/git-training/alice
    \end{Verbatim}

    The next step for Emma is to ask Alice to get the \textbf{baz} branch
from \textbf{central-emma-fork} pulled into the \textbf{master} branch
of \textbf{central}.

Note: GitHub provides functionnality to request a pull, and review the
associated code.

Alice fetches Emma's bare repository. To do this, she first adds Emma's
bare repository to the list of her remote repositories.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}79}]:} \PY{o}{\PYZpc{}\PYZpc{}}\PY{k}{bash}
         \PY{n}{git} \PY{n}{remote} \PY{n}{add} \PY{n}{emma} \PY{n+nb}{file}\PY{p}{:}\PY{o}{/}\PY{o}{/}\PY{err}{\PYZdl{}}\PY{n}{HOME}\PY{o}{/}\PY{n}{git}\PY{o}{\PYZhy{}}\PY{n}{training}\PY{o}{/}\PY{n}{central}\PY{o}{\PYZhy{}}\PY{n}{emma}\PY{o}{\PYZhy{}}\PY{n}{fork}\PY{o}{.}\PY{n}{git}
         \PY{n}{git} \PY{n}{fetch} \PY{n}{emma}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
From file:///home/ROCQ/sedrocq/froger/git-training/central-emma-fork
 * [new branch]      baz        -> emma/baz
 * [new branch]      exp        -> emma/exp
 * [new branch]      master     -> emma/master
    \end{Verbatim}

    At this point, Alice and Emmma can interact with each other to add more
commits to the \texttt{baz} branch. When her work is done, Alice merges
it to \texttt{master}, and \texttt{pushes}.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}80}]:} \PY{o}{\PYZpc{}\PYZpc{}}\PY{k}{bash}
         \PY{n}{git} \PY{n}{checkout} \PY{n}{master}
         \PY{n}{git} \PY{n}{merge} \PY{n}{emma}\PY{o}{/}\PY{n}{baz}
         \PY{n}{git} \PY{n}{push} \PY{n}{origin} \PY{n}{master}\PY{p}{:}\PY{n}{master}
\end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
Updating f08edac..80e082f
Fast-forward
 bar.txt |    3 +++
 baz.txt |    2 ++
 foo.txt |    2 ++
 3 files changed, 7 insertions(+)
 create mode 100644 bar.txt
 create mode 100644 baz.txt
    \end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
Switched to branch 'master'
To file:///nas/home3/f/froger/git-training/central.git
   5a1c308..80e082f  master -> master
    \end{Verbatim}


    \subsection{Exercice}


    This exerice continues on the previous one, and re-use its Git
repository. This will be the repository of the first developer.

0- Create a bare repository for the first developer.

1- Push existing commits to this repository.

2- Set up a bare repository and a fork for a second developer.

3- The second developer creates a feature branch, and pushes it to its
bare repository.

4- The first developer get the feature branch of the second developer,
and pushes it to its bare repository.


    \subsection{References}


    \begin{quote}
http://www.git-scm.com/docs

\end{quote}
\begin{quote}
http://githowto.com

\end{quote}
\begin{quote}
``Version Control with Git, Powerful tools and techniques for
collaborative software development'' By Jon Loeliger, Matthew McCullough

\end{quote}
\begin{quote}
HitHug let's you learn Git through a nice game:
https://github.com/gazler/githug

\end{quote}
\begin{quote}
Another game: https://github.com/jlord/git-it

\end{quote}


    % Add a bibliography block to the postdoc
    
    
    
    \end{document}
